import pandas as pd
import numpy as np
import os
import json
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.tsa.arima.model import ARIMA
from prophet import Prophet
import warnings
warnings.filterwarnings('ignore') # Suppress warnings for cleaner output

# ====================================================================
# DEFINE NECESSARY FILE PATHS AND NAMES
# (Ensure these files have been generated by your preprocessing notebook)
# ====================================================================

# Root directory where processed folds are saved
output_base_dir = 'data/processed_folds' 

# File containing the summary of all folds
folds_summary_file = os.path.join(output_base_dir, 'folds_summary.json')

# Paths to load the saved tuning results
tuning_results_dir = 'data/tuning_results'
arima_tuning_results_input_path = os.path.join(tuning_results_dir, 'final_arima_tuning_results.json')
prophet_tuning_results_input_path = os.path.join(tuning_results_dir, 'final_prophet_tuning_results.json')

# ====================================================================
# LOAD SAVED TUNING RESULTS FROM PREVIOUS RUNS
# ====================================================================
print(f"Loading ARIMA tuning results from: {arima_tuning_results_input_path}")
with open(arima_tuning_results_input_path, 'r') as f:
    arima_tuned_params_per_fold = json.load(f)

print(f"Loading Prophet tuning results from: {prophet_tuning_results_input_path}")
with open(prophet_tuning_results_input_path, 'r') as f:
    prophet_tuned_params_per_fold = json.load(f)

# Convert list of tuning results to dictionaries for easier access by (fold_id, ticker)
arima_params_dict = {(res['fold_id'], res['ticker']): res['best_params'] for res in arima_tuned_params_per_fold}
prophet_params_dict = {(res['fold_id'], res['ticker']): res['best_params'] for res in prophet_tuned_params_per_fold}

# Load fold information
print(f"Loading fold summary from: {folds_summary_file}")
with open(folds_summary_file, 'r') as f:
    all_folds_summary = json.load(f)

folds_summary_dict = {fold['global_fold_id']: fold for fold in all_folds_summary}

# ====================================================================
# SELECT FOLDS FOR VISUALIZATION
# (You can adjust this list to choose which specific folds to display)
# ====================================================================
# Example: Select the first fold for each ticker.
# IMPORTANT: Make sure these fold IDs actually exist in your tuning results!
# You might need to inspect your final_arima_tuning_results.json to see which fold_ids were tuned.
# For instance, if tuning was only done for fold_id 104, then folds_to_visualize should only contain [104].
folds_to_visualize = [0, 104, 208, 312, 388, 492, 596] 
# Check if tuning results exist for these folds, and filter the list
valid_folds_to_visualize = []
for fid in folds_to_visualize:
    if (fid, folds_summary_dict[fid]['ticker']) in arima_params_dict and \
       (fid, folds_summary_dict[fid]['ticker']) in prophet_params_dict:
        valid_folds_to_visualize.append(fid)
    else:
        print(f"  Warning: No tuning results found for Fold {fid} ({folds_summary_dict[fid]['ticker']}). Skipping visualization.")

folds_to_visualize = valid_folds_to_visualize

print(f"\nVisualizing predictions for {len(folds_to_visualize)} selected folds with available tuning results...")
if not folds_to_visualize:
    print("No valid folds to visualize. Please ensure tuning results exist for the selected folds.")

# ====================================================================
# MAIN LOOP: LOAD DATA, RETRAIN WITH OPTIMAL PARAMS, AND VISUALIZE
# ====================================================================

for fold_id in folds_to_visualize:
    fold_info = folds_summary_dict[fold_id]
    selected_ticker = fold_info['ticker']

    print(f"\n--- Processing Fold ID: {fold_id} for {selected_ticker} ---")
    
    # --- STEP 1: LOAD PREPROCESSED AND FEATURE-ENGINEERED DATA ---
    train_path_ap = os.path.join(output_base_dir, fold_info['train_path_arima_prophet'])
    val_path_ap = os.path.join(output_base_dir, fold_info['val_path_arima_prophet'])
    
    current_train_data_ap = pd.read_csv(train_path_ap)
    current_val_data_ap = pd.read_csv(val_path_ap)

    # Convert 'Date' column to datetime type
    current_train_data_ap['Date'] = pd.to_datetime(current_train_data_ap['Date'])
    current_val_data_ap['Date'] = pd.to_datetime(current_val_data_ap['Date'])

    # --- IMPORTANT FIX: Ensure 'Date' column is unique and set as index ---
    # This is crucial for proper alignment of time series data
    current_train_data_ap = current_train_data_ap.set_index('Date').sort_index()
    current_val_data_ap = current_val_data_ap.set_index('Date').sort_index()
    
    # Drop duplicates in index if any remain (keep first occurrence)
    if current_train_data_ap.index.duplicated().any():
        print(f"  Warning: Duplicate dates found in train index for fold {fold_id}. Dropping duplicates.")
        current_train_data_ap = current_train_data_ap.loc[~current_train_data_ap.index.duplicated(keep='first')]
    if current_val_data_ap.index.duplicated().any():
        print(f"  Warning: Duplicate dates found in validation index for fold {fold_id}. Dropping duplicates.")
        current_val_data_ap = current_val_data_ap.loc[~current_val_data_ap.index.duplicated(keep='first')]


    # Retrieve optimal hyperparameters for the current fold
    best_arima_params = arima_params_dict.get((fold_id, selected_ticker))
    best_prophet_params = prophet_params_dict.get((fold_id, selected_ticker))

    # This check is already done when filtering folds_to_visualize, but kept for safety.
    if best_arima_params is None or best_prophet_params is None:
        print(f"  Error: Tuning results unexpectedly missing for Fold {fold_id} ({selected_ticker}). Skipping.")
        continue

    # ====================================================================
    # RETRAIN MODELS WITH OPTIMAL PARAMETERS AND GENERATE DETAILED PREDICTIONS
    # ====================================================================

    # --- 1. Predictions for ARIMA ---
    print(f"  Generating ARIMA predictions with best parameters: {best_arima_params}")
    arima_train_series_for_final_model = current_train_data_ap['Log_Returns'].copy()
    
    # Get the last closing price of the training set (from its index)
    last_train_close_arima = current_train_data_ap['Close'].iloc[-1]

    # Retrain the ARIMA model with the best parameters
    # The ARIMA model expects a Series or array without a MultiIndex if exog is not used
    final_arima_model = ARIMA(arima_train_series_for_final_model, 
                              order=(best_arima_params['p'], best_arima_params['d'], best_arima_params['q']))
    final_arima_model_fit = final_arima_model.fit()

    # Predict on the training set (in-sample prediction)
    arima_train_forecast_log_returns = final_arima_model_fit.predict(start=0, end=len(arima_train_series_for_final_model) - 1)
    
    # Predict on the validation set (out-of-sample forecast) and get confidence intervals
    forecast_result_arima = final_arima_model_fit.get_forecast(steps=len(current_val_data_ap))
    arima_val_forecast_log_returns = forecast_result_arima.predicted_mean
    arima_val_conf_int = forecast_result_arima.conf_int(alpha=0.05) # 95% confidence interval

    # Convert predicted Log_Returns to Close Price for the training set
    # Create a shifted Close price series for inverse transformation.
    # The index of arima_train_predicted_close must match the actual dates.
    arima_train_close_actual_shifted = current_train_data_ap['Close'].shift(1)
    # For the very first prediction in the training set, use the actual Close price of that day
    arima_train_close_actual_shifted.iloc[0] = current_train_data_ap['Close'].iloc[0] 
    arima_train_predicted_close = pd.Series(
        arima_train_close_actual_shifted * np.exp(arima_train_forecast_log_returns),
        index=current_train_data_ap.index # Assign the correct date index
    )

    # Convert predicted Log_Returns to Close Price for the validation set
    arima_val_close_actual_shifted = current_val_data_ap['Close'].shift(1)
    # For the first day of validation, use the last Close from training data
    arima_val_close_actual_shifted.iloc[0] = last_train_close_arima 
    arima_val_predicted_close = pd.Series(
        arima_val_close_actual_shifted * np.exp(arima_val_forecast_log_returns),
        index=current_val_data_ap.index # Assign the correct date index
    )
    
    # Convert ARIMA's confidence intervals to Close Price scale
    arima_val_lower_bound_close = pd.Series(
        arima_val_close_actual_shifted * np.exp(arima_val_conf_int.iloc[:, 0]),
        index=current_val_data_ap.index # Assign the correct date index
    )
    arima_val_upper_bound_close = pd.Series(
        arima_val_close_actual_shifted * np.exp(arima_val_conf_int.iloc[:, 1]),
        index=current_val_data_ap.index # Assign the correct date index
    )


    # --- 2. Predictions for PROPHET ---
    print(f"  Generating Prophet predictions with best parameters: {best_prophet_params}")
    # Prophet requires 'ds' as date column and 'y' as target column
    prophet_train_df_for_final_model = current_train_data_ap.reset_index()[['Date', 'Log_Returns']].rename(columns={'Date': 'ds', 'Log_Returns': 'y'})
    prophet_val_df_for_final_model = current_val_data_ap.reset_index()[['Date', 'Log_Returns']].rename(columns={'Date': 'ds', 'Log_Returns': 'y'})
    last_train_close_prophet = current_train_data_ap['Close'].iloc[-1]

    final_prophet_model = Prophet(
        changepoint_prior_scale=best_prophet_params['changepoint_prior_scale'],
        seasonality_prior_scale=best_prophet_params['seasonality_prior_scale'],
        seasonality_mode=best_prophet_params['seasonality_mode'],
        daily_seasonality=False
    )
    final_prophet_model.fit(prophet_train_df_for_final_model)

    # Create a future DataFrame for both training and validation sets to get in-sample and out-of-sample predictions
    future_prophet_full = final_prophet_model.make_future_dataframe(periods=len(prophet_val_df_for_final_model), include_history=True)
    forecast_prophet_full_df = final_prophet_model.predict(future_prophet_full)

    # Prophet's forecast_prophet_full_df already has 'ds' as its index, which is what we need.
    # Align it with the original DataFrame's Date index
    forecast_prophet_full_df = forecast_prophet_full_df.set_index('ds')
    
    # Ensure no duplicates in the forecast index if include_history=True and original data had issues
    if forecast_prophet_full_df.index.duplicated().any():
        forecast_prophet_full_df = forecast_prophet_full_df.loc[~forecast_prophet_full_df.index.duplicated(keep='first')]


    # Align original train/val data to the forecast index for inverse transformation
    # This creates a combined series of actual 'Close' prices, aligned with the full forecast dates.
    combined_actual_close_prophet = pd.concat([current_train_data_ap['Close'], current_val_data_ap['Close']]).sort_index()
    combined_actual_close_prophet = combined_actual_close_prophet.loc[~combined_actual_close_prophet.index.duplicated(keep='first')]

    # Create a shifted Close price series based on the full actual close for inverse transformation
    # Fill NaN for the very first element using the actual Close price of the first day in the full combined series
    shifted_full_close_prophet = combined_actual_close_prophet.shift(1)
    shifted_full_close_prophet.iloc[0] = combined_actual_close_prophet.iloc[0] 
    
    # Calculate full predicted close prices
    full_prophet_predicted_close = shifted_full_close_prophet * np.exp(forecast_prophet_full_df['yhat'])
    full_prophet_lower_bound_close = shifted_full_close_prophet * np.exp(forecast_prophet_full_df['yhat_lower'])
    full_prophet_upper_bound_close = shifted_full_close_prophet * np.exp(forecast_prophet_full_df['yhat_upper'])
    
    # For plotting, we need these aligned back to the original full_date_range from the actual data.
    # This involves reindexing if Prophet's future_dataframe created dates not present in original data
    # (unlikely for stock data unless there were missing days in original data itself)

    # The actual dates for the fill_between function (validation period only)
    val_dates_for_fill_prophet = current_val_data_ap.index 


    # ====================================================================
    # VISUALIZE PREDICTION RESULTS AND CONFIDENCE INTERVALS
    # ====================================================================

    # Create a unified DataFrame for plotting (including both train and val data)
    # Using current_train_data_ap.index and current_val_data_ap.index directly
    # since they are already datetime indices and should be unique after our fix.
    full_arima_predicted_close = pd.concat([arima_train_predicted_close, arima_val_predicted_close]).sort_index()
    full_actual_close_series = pd.concat([current_train_data_ap['Close'], current_val_data_ap['Close']]).sort_index()
    
    # Make sure prediction series are indexed by date for plotting
    arima_predicted_close_full_plot = full_arima_predicted_close.reindex(full_actual_close_series.index)
    prophet_predicted_close_full_plot = full_prophet_predicted_close.reindex(full_actual_close_series.index)

    # Ensure CI bounds are also indexed by date for plotting fill_between
    arima_val_lower_bound_close_plot = arima_val_lower_bound_close.reindex(val_dates_for_fill_prophet)
    arima_val_upper_bound_close_plot = arima_val_upper_bound_close.reindex(val_dates_for_fill_prophet)
    prophet_val_lower_bound_close_plot = full_prophet_lower_bound_close.reindex(val_dates_for_fill_prophet)
    prophet_val_upper_bound_close_plot = full_prophet_upper_bound_close.reindex(val_dates_for_fill_prophet)


    # --- ARIMA Plot ---
    plt.figure(figsize=(15, 7))
    plt.plot(full_actual_close_series.index, full_actual_close_series, label='Actual Close Price', color='blue')
    plt.plot(arima_predicted_close_full_plot.index, arima_predicted_close_full_plot, 
             label='ARIMA Predicted Close Price', color='red', linestyle='--')
    plt.fill_between(val_dates_for_fill_prophet, arima_val_lower_bound_close_plot, arima_val_upper_bound_close_plot, 
                     color='red', alpha=0.1, label='ARIMA 95% Confidence Interval')

    # Mark the boundary between training and validation sets
    train_end_date_arima = current_train_data_ap.index.max()
    plt.axvline(train_end_date_arima, color='gray', linestyle=':', label='Train/Validation Split')

    plt.title(f'ARIMA: Actual vs. Predicted Close Price for {selected_ticker} (Fold ID: {fold_id})')
    plt.xlabel('Date')
    plt.ylabel('Close Price')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # --- Prophet Plot ---
    plt.figure(figsize=(15, 7))
    plt.plot(full_actual_close_series.index, full_actual_close_series, label='Actual Close Price', color='blue')
    plt.plot(prophet_predicted_close_full_plot.index, prophet_predicted_close_full_plot, 
             label='Prophet Predicted Close Price', color='green', linestyle='--')
    plt.fill_between(val_dates_for_fill_prophet, prophet_val_lower_bound_close_plot, prophet_val_upper_bound_close_plot, 
                     color='green', alpha=0.1, label='Prophet 95% Confidence Interval')

    # Mark the boundary between training and validation sets
    train_end_date_prophet = current_train_data_ap.index.max()
    plt.axvline(train_end_date_prophet, color='gray', linestyle=':', label='Train/Validation Split')

    plt.title(f'Prophet: Actual vs. Predicted Close Price for {selected_ticker} (Fold ID: {fold_id})')
    plt.xlabel('Date')
    plt.ylabel('Close Price')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

print("\n--- Visualization process complete. ---")



# ====================================================================
# VISUALIZATION ON THE FINAL TEST SET
# ====================================================================

print("\n--- Starting Visualization on the FINAL TEST SET ---")

# --- STEP 1: CHOOSE THE BEST OVERALL HYPERPARAMETERS ---
best_overall_arima_result = min(arima_tuned_params_per_fold, key=lambda x: x['best_rmse'])
best_overall_prophet_result = min(prophet_tuned_params_per_fold, key=lambda x: x['best_rmse'])

selected_ticker_for_test_plot = best_overall_arima_result['ticker'] # Use ticker from the best ARIMA fold

best_overall_arima_params = best_overall_arima_result['best_params']
best_overall_prophet_params = best_overall_prophet_result['best_params']

print(f"\nBest overall ARIMA params (from fold {best_overall_arima_result['fold_id']}): {best_overall_arima_params}")
print(f"Best overall Prophet params (from fold {best_overall_prophet_result['fold_id']}): {best_overall_prophet_params}")


# --- STEP 2: LOAD THE FULL TRAIN+VAL DATASET FOR FINAL MODEL TRAINING ---
full_train_val_data_path = 'data/transformed/data_final_with_basic_transforms_and_skewness_corrected.csv'
try:
    full_train_val_df_ap = pd.read_csv(full_train_val_data_path)
    # Filter for the selected ticker for test plot, as overall model is trained on specific ticker's data
    full_train_val_df_ap = full_train_val_df_ap[full_train_val_df_ap['Ticker'] == selected_ticker_for_test_plot].copy()
    full_train_val_df_ap['Date'] = pd.to_datetime(full_train_val_df_ap['Date'])
    full_train_val_df_ap = full_train_val_df_ap.set_index('Date').sort_index()
    full_train_val_df_ap = full_train_val_df_ap.loc[~full_train_val_df_ap.index.duplicated(keep='first')]
except FileNotFoundError:
    print(f"Error: Full train+val data file not found at {full_train_val_data_path}. Skipping final test visualization.")
    exit()

# --- STEP 3: LOAD THE FINAL TEST DATASET ---
final_test_data_path = 'data/cleaned/test_set.csv' 
try:
    final_test_df_ap = pd.read_csv(final_test_data_path)
    # Filter for the selected ticker for test plot
    final_test_df_ap = final_test_df_ap[final_test_df_ap['Ticker'] == selected_ticker_for_test_plot].copy()
    final_test_df_ap['Date'] = pd.to_datetime(final_test_df_ap['Date'])
    final_test_df_ap = final_test_df_ap.set_index('Date').sort_index()
    final_test_df_ap = final_test_df_ap.loc[~final_test_df_ap.index.duplicated(keep='first')]
except FileNotFoundError:
    print(f"Error: Final test data file not found at {final_test_data_path}. Skipping final test visualization.")
    exit()

# --- Check if there's enough data after filtering for the selected ticker ---
if full_train_val_df_ap.empty or final_test_df_ap.empty:
    print(f"  Error: Data for ticker '{selected_ticker_for_test_plot}' not found or empty in full train+val or test set. Cannot plot final test visualization.")
else:
    # --- STEP 4: RETRAIN FINAL MODELS ON FULL TRAIN+VAL DATA AND PREDICT ON TEST SET ---

    # --- 1. Final ARIMA Model (Overall) ---
    print(f"  Training final ARIMA model on full train+val data for {selected_ticker_for_test_plot}...")
    final_arima_train_series_overall = full_train_val_df_ap['Log_Returns'].copy()
    last_train_val_close_arima_overall = full_train_val_df_ap['Close'].iloc[-1]

    final_arima_model_overall = ARIMA(final_arima_train_series_overall, 
                                      order=(best_overall_arima_params['p'], 
                                             best_overall_arima_params['d'], 
                                             best_overall_arima_params['q']))
    final_arima_model_fit_overall = final_arima_model_overall.fit()

    # Predict on the test set
    # Create a future dataframe for ARIMA with the exact test set dates
    arima_test_dates = pd.DataFrame(index=final_test_df_ap.index) # Use the index from final_test_df_ap
    
    forecast_result_arima_test = final_arima_model_fit_overall.get_forecast(steps=len(arima_test_dates))
    arima_test_forecast_log_returns = forecast_result_arima_test.predicted_mean
    arima_test_conf_int = forecast_result_arima_test.conf_int(alpha=0.05)
    
    # Ensure forecast results have the same index as the test set
    arima_test_forecast_log_returns.index = arima_test_dates.index
    arima_test_conf_int.index = arima_test_dates.index

    # Convert to Close Price
    arima_test_close_actual_shifted = final_test_df_ap['Close'].shift(1)
    arima_test_close_actual_shifted.iloc[0] = last_train_val_close_arima_overall # Use last close from full train+val data
    arima_test_predicted_close = arima_test_close_actual_shifted * np.exp(arima_test_forecast_log_returns)

    arima_test_lower_bound_close = arima_test_close_actual_shifted * np.exp(arima_test_conf_int.iloc[:, 0])
    arima_test_upper_bound_close = arima_test_close_actual_shifted * np.exp(arima_test_conf_int.iloc[:, 1])


    # --- 2. Final Prophet Model (Overall) ---
    print(f"  Training final Prophet model on full train+val data for {selected_ticker_for_test_plot}...")
    prophet_train_df_overall = full_train_val_df_ap.reset_index()[['Date', 'Log_Returns']].rename(columns={'Date': 'ds', 'Log_Returns': 'y'})
    last_train_val_close_prophet_overall = full_train_val_df_ap['Close'].iloc[-1]

    final_prophet_model_overall = Prophet(
        changepoint_prior_scale=best_overall_prophet_params['changepoint_prior_scale'],
        seasonality_prior_scale=best_overall_prophet_params['seasonality_prior_scale'],
        seasonality_mode=best_overall_prophet_params['seasonality_mode'],
        daily_seasonality=False
    )
    final_prophet_model_overall.fit(prophet_train_df_overall)

    # Predict on the test set
    # Create a future dataframe for Prophet with the exact test set dates
    # Prophet's future_dataframe expects 'ds' as column, not index
    prophet_test_future = pd.DataFrame({'ds': final_test_df_ap.index.to_list()}) 
    
    forecast_prophet_test_df = final_prophet_model_overall.predict(prophet_test_future)

    # Set 'ds' as index for the Prophet forecast DataFrame
    forecast_prophet_test_df = forecast_prophet_test_df.set_index('ds')
    if forecast_prophet_test_df.index.duplicated().any():
        forecast_prophet_test_df = forecast_prophet_test_df.loc[~forecast_prophet_test_df.index.duplicated(keep='first')]

    prophet_test_close_actual_shifted = final_test_df_ap['Close'].shift(1)
    prophet_test_close_actual_shifted.iloc[0] = last_train_val_close_prophet_overall
    prophet_test_predicted_close = prophet_test_close_actual_shifted * np.exp(forecast_prophet_test_df['yhat'])

    prophet_test_lower_bound_close = prophet_test_close_actual_shifted * np.exp(forecast_prophet_test_df['yhat_lower'])
    prophet_test_upper_bound_close = prophet_test_close_actual_shifted * np.exp(forecast_prophet_test_df['yhat_upper'])


    # --- STEP 5: VISUALIZE FINAL PREDICTIONS ON TEST SET ---
    # Combine full train_val actual close with test actual close for plotting
    full_actual_close_test_series = pd.concat([full_train_val_df_ap['Close'], final_test_df_ap['Close']]).sort_index()
    full_actual_close_test_series = full_actual_close_test_series.loc[~full_actual_close_test_series.index.duplicated(keep='first')]

    # Ensure all series for plotting have the same index as full_actual_close_test_series
    arima_test_predicted_close_plot = arima_test_predicted_close.reindex(final_test_df_ap.index)
    arima_test_lower_bound_close_plot = arima_test_lower_bound_close.reindex(final_test_df_ap.index)
    arima_test_upper_bound_close_plot = arima_test_upper_bound_close.reindex(final_test_df_ap.index)
    
    prophet_test_predicted_close_plot = prophet_test_predicted_close.reindex(final_test_df_ap.index)
    prophet_test_lower_bound_close_plot = prophet_test_lower_bound_close.reindex(final_test_df_ap.index)
    prophet_test_upper_bound_close_plot = prophet_test_upper_bound_close.reindex(final_test_df_ap.index)


    # ARIMA Plot on Test Set
    plt.figure(figsize=(15, 7))
    plt.plot(full_actual_close_test_series.index, full_actual_close_test_series, label='Actual Close Price (Full Data)', color='blue')
    plt.plot(final_test_df_ap.index, arima_test_predicted_close_plot, label='ARIMA Predicted Close Price (Test Set)', color='red', linestyle='--')
    plt.fill_between(final_test_df_ap.index, arima_test_lower_bound_close_plot, arima_test_upper_bound_close_plot, 
                     color='red', alpha=0.1, label='ARIMA 95% Confidence Interval (Test Set)')

    plt.axvline(full_train_val_df_ap.index.max(), color='gray', linestyle=':', label='Train+Val/Test Split')
    plt.title(f'ARIMA: Actual vs. Predicted Close Price on Test Set for {selected_ticker_for_test_plot} (Overall Best Model)')
    plt.xlabel('Date')
    plt.ylabel('Close Price')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

    # Prophet Plot on Test Set
    plt.figure(figsize=(15, 7))
    plt.plot(full_actual_close_test_series.index, full_actual_close_test_series, label='Actual Close Price (Full Data)', color='blue')
    plt.plot(final_test_df_ap.index, prophet_test_predicted_close_plot, label='Prophet Predicted Close Price (Test Set)', color='green', linestyle='--')
    plt.fill_between(final_test_df_ap.index, prophet_test_lower_bound_close_plot, prophet_test_upper_bound_close_plot, 
                     color='green', alpha=0.1, label='Prophet 95% Confidence Interval (Test Set)')

    plt.axvline(full_train_val_df_ap.index.max(), color='gray', linestyle=':', label='Train+Val/Test Split')
    plt.title(f'Prophet: Actual vs. Predicted Close Price on Test Set for {selected_ticker_for_test_plot} (Overall Best Model)')
    plt.xlabel('Date')
    plt.ylabel('Close Price')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

print("\n--- Final test set visualization complete. ---")